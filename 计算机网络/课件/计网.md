# 第一章：引言

## 重点：

```
掌握典型交换方式及其优缺点

 掌握分层结构和网络协议（核心内容）

掌握网络参考模型（核心内容）

掌握计算机网络主要度量的含义
```



## 典型交换方式

### 电路交换

![image-20211222114557363](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222114557363.png)

![image-20211222114614187](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222114614187.png)



### 存储转发的报文交换

![image-20211222114641716](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222114641716.png)



### 分组交换

![image-20211222114702222](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222114702222.png)

![image-20211222114726491](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222114726491.png)

### 三种交换方式比较

![image-20211222114755990](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222114755990.png)



## 协议和分层结构



#### 协议目的：

**网络协议**：

• 为进行网络中的数据交换而建立的规则、标准或约定，即网络协议(network protocol)

• 通信双方需要共同遵守，互相理解

**三要素：**

• 语法：规定传输数据的格式（如何讲）

• 语义：规定所要完成的功能（讲什么）

• 时序：规定各种操作的顺序（双方讲话的顺序）



### 协议分层结构

**层次栈**：

为降低网络设计的复杂性，网络使用层次结构的协议栈，每一层都使用其下一层所提供的服务，并为上层提供自己的服务



**对等实体**

不同机器上构成相应层次的实体称为对等实体



**接口**

在每一对相邻层次之间的是接口；接口定义了下层向上层提供哪些服务原语



**网络体系结构**

层和协议的集合为网络体系结构，一个特定的系统所使用的一组协议，即每层的协议，称为协议栈



### 服务原语

#### 服务：

**典型服务：**面向连接的传输服务，无连接传输服务

原语告诉服务执行某些操作或报告对等实体所采取的操作



**六个核心服务原语（以面向连接服务为例）**

![image-20211222112918395](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222112918395.png)



#### 服务和协议的关系

协议是“水平”的，服务是“垂直”的 

实体使用协议来实现其定义的服务

上层实体通过接口使用下层实体的服务



## 参考模型

### OSI参考模型

![image-20211222113134030](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222113134030.png)

![image-20211222113214635](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222113214635.png)

![image-20211222113238766](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222113238766.png)

![image-20211222113259127](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222113259127.png)

![image-20211222113321555](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222113321555.png)

![image-20211222113331160](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222113331160.png)



### TCP/IP参考模型

![image-20211222113413387](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222113413387.png)

![image-20211222113506924](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222113506924.png)



### OSI模型和TCP/IP模型比较

![image-20211222113613940](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222113613940.png)



![image-20211222113638731](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222113638731.png)



### 五层分层模型

![image-20211222113722016](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222113722016.png)



## 计算机网络的度量单位

**比特率(bit rate)**

• 主机在数字信道上传送数据的速率，也称数据率

• 比特率的单位是b/s(比特每秒)，也可以写为bps， (bit per second)，或 kbit/s、Mbit/s、 Gbit/s等



**带宽**

• 网络中某通道传送数据的能力，即单位时间内网络中的某信道所能通过的“最高数据率” 

• 单位是 bit/s，即 “比特每秒



**包转发率(PPS)** ****

·全称是Packet Per Second(包/秒)，表示交换机或路 由器等网络设备以包为单位的转发速率

• 线速转发：交换机端口在满负载的情况下，对帧进 行转发时能够达到该端口线路的最高速度



**时延**

• 时延 (delay 或 latency) 是指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需的时间，也称为延迟

• 传输时延(transmission delay)：数据从结点进入到传输媒体所需要的时间，传输时延又称为发送时延

• 传播时延(propagation delay)：电磁波在信道中需要传播一定距离而花费的时间 

• 处理时延(processing delay)：主机或路由器在收到分组时，为处理分组（例 如分析首部、提取数据、差错检验或查找路由）所花费的时间 

• 排队时延(queueing delay)：分组在路由器输入输出队列中排队等待处理所经历的时延 



**往返时延RTT(Round-Trip Time)**

• 从发送方发送数据开始，到发送方收到来自接收方的确认，经历的总时间 

• 可用于判断网络的通断性、测试网络时延、计算数据包丢失率等



**时延带宽积**

• 时延带宽积 = 传播时延 ´ 带宽，即按比特计数的链路长度

• 若发送端连续发送数据，则在发送的第一个bit即将达到终点时，发送端就 已经发送了时延带宽积个bit ，而这些bit都在链路上向前

![image-20211222114239370](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222114239370.png)



**吞吐量 (throughput)** 

• 单位时间内通过某个网络(或信道、接口)的数据量，单位是 b/s 



 **有效吞吐量(goodput)**

• 单位时间内，目的地正确接收到的有用信息的数目（以 bit 为单位） 



 **利用率**

• 信道利用率指出某信道有百分之几的时间是被利用的

• 网络利用率则是全网络的信道利用率的加权平均值 



**丢包率** 

• 所丢失数据包的数量占所发送数据包的比率



**时延抖动**

• 变化的时延称为抖动（Jitter） 

• 时延抖动起源于网络中的队列或 缓冲，抖动难以精确预测

• 在语音、视频多媒体业务中，抖 动往往会严重影响用户的体验 



**延迟丢包**

• 在多媒体应用中，由于数据包延

迟到达，在接收端需要丢弃失去

使用价值的包



# 物理层

### 重点

理解物理层基本概念、功能和基本特性

掌握不同多路复用技术的基本原理和特点



### 物理层基本概念

#### 物理层的功能

![image-20211222114922082](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222114922082.png)



#### 物理层接口特性

![image-20211222114943495](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222114943495.png)



#### 物理层机械特性

涉及接口的物理结构，通常采用接线器来实现机械上的连接

定义接线器的**形状和尺寸、引线数目和排列、固定和锁定装置**等



#### 物理层电气特性

#### ![image-20211222115147300](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222115147300.png)



#### 物理层功能特性

描述接口执行的功能，定义接线器的每一引脚(针，Pin)的作用



#### 物理层过程特性

指明对于不同功能的各种可能事件的出现顺序



![image-20211222115405259](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222115405259.png)



### 多路复用技术

**复用技术**

Ø 信道资源是有限的，实际网络中，多对用户往往需要利用相同的信道资源传输信息

Ø 不同的信号同时在同一信道中传输会产生严重的相互干扰，导致传输失败。

复用 (multiplexing) 技 术的目的是：允许用 户使用一个共享信道进行通信，避免相互干扰，降低成本，提高利用率。



#### 频发复用FDM

![image-20211222115718142](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222115718142.png)



#### 时分复用TDM

![image-20211222115742629](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222115742629.png)

![image-20211222115751867](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222115751867.png)



#### 统计时分复用STDM

![image-20211222115959463](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222115959463.png)



#### 波分复用WDM

![image-20211222120029283](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222120029283.png)



#### 码分复用CDMA

![image-20211222120114293](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222120114293.png)

![image-20211222120139154](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222120139154.png)

![image-20211222120315489](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222120315489.png)

![image-20211222120324748](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222120324748.png)



# 数据链路层

## 重点

掌握差错检测和纠正的基本原理和典型的编码方法（核心内容）

掌握无错信道和有错信道上停等协议的设计和实现方法（核心内容）

掌握回退N和选择重传两种典型滑动窗口协议的工作机制（核心内容）



## 数据链路层设计

### 在协议栈中的位置

向上：为网络层提供明确的服务接口

向下：利用物理层提供的位流服务

分为：介质访问控制（MAC）和逻辑链路控制（LLC）

![image-20211222134722531](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222134722531.png)



### 链路层的功能：

 

**成帧** （Framing） 

​	• 将比特流划分成“帧”的主要目的是为了检测和纠正物理层在比特传输中可能出现的错误，数据链路层功能需借助“帧”的各个域来实现 

**差错控制** （Error Control） 

​	• 处理传输中出现的差错，如位错误、丢失等 

**流量控制** （Flow Control） 

​	• 确保发送方的发送速率，不大于接收方的处理速率

​	− 避免接收缓冲区溢出



## 差错检测和纠正

**如何解决信道传输差错问题** 

​	• 通常采用增加冗余信息（或称校验信息）的策略

**目标**：保证一定差错检测和纠错能力的前提下，如何减少冗余信息量？

**考虑的问题**

​	• 传输需求 

​	• 冗余信息的计算方法、携带的冗余信息量

​	• 计算的复杂度等 

**两种主要策略**

• 检错码（error-detecting code） 

```
·在被发送的数据块中，包含一些冗余信息，但这些信息只能使接收方推 

断是否发生错误，但不能推断哪位发生错误，接收方可以请求发送方重

传数据

• 主要用在高可靠、误码率较低的信道上，例如光纤链路 

• 偶尔发生的差错，可以通过重传解决差错问题
```



• 纠错码（error-correcting code) 

```
• 发送方在每个数据块中加入足够的冗余信息，使得接收方能够判断接收到
的数据是否有错，并能纠正错误（定位出错的位置）
• 主要用于错误发生比较频繁的信道上，如无线链路
• 也经常用于物理层，以及更高层（例如，实时流媒体应用和内容分发）
• 使用纠错码的技术通常称为前向纠错（FEC，Forward Error Correction)
```

**码字 (code word)**：一个包含m个数据位和r个校验位的n位单元

​	• 描述为 (n, m) 码，n=m+r 

 **码率 (code rate)**：码字中不含冗余部分所占的比例，可以用m/n表示

**海明距离** (Hamming distance)：两个码字之间不同对应比特的数目

```
• 例：0000000000 与0000011111的海明距离为5 

• 如果两个码字的海明距离为d，则需要d个单比特错就可以把一个码字转换成另一 个码字

• 为了检查出d个错（比特错），可以使用海明距离为 **d+1** 的编码

• 为了纠正d个错，可以使用海明距离为 **2d+1** 的编码

• 一个只有4个有效码字的编码方案：0000000000, 0000011111,
1111100000, 1111111111
• 海明距离为5，可以检测4位错，纠正2位错
• 如果已知只有1位或2位错误，接收方接收0000000111
− 则可知原码字为：0000011111
• 如果发生至多3位错误，例如0000000000变成0000000111，接收方无法纠正错误，但可以检测出错误
```



### 典型检错码：

• 奇偶检验 (Parity Check)：1位奇偶校验是最简单、最基础的检错码 

• 校验和 (Checksum)：主要用于TCP/IP体系中的网络层和传输层

• 循环冗余校验 (Cyclic Redundancy Check，CRC)：数据链路层广泛使用的校验方法



#### 奇偶校验：

**![image-20211222140650327](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222140650327.png)**



#### 校验和

![image-20211222140708759](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222140708759.png)

```
二进制补码求和

```



#### 循环冗余校验CRC

![image-20211222141408238](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222141408238.png)

![image-20211222141414222](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222141414222.png)

![image-20211222141420390](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222141420390.png)



### 纠错码

#### 海明码

发现双比特错，纠正单比特错

![image-20211222142313389](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222142313389.png)

![image-20211222142507064](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222142507064.png)

**![image-20211222142157397](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222142157397.png)**



## 基本数据链路协议

### 定义与假设

 分层进程独立假设

​	• 网络层、数据链路层、物理层为独立的进程

​	• 进程间通过传递消息实现通信

 提供可靠服务假设

​	• 提供可靠的、面向连接的服务

​	• 网络层可随时获得数据链路层发送的数据

只处理通信错误假设

​	• 仅处理通信错误

​	• 假设机器不会崩溃，不考虑断电、重启等引起的问题



### 乌托邦式单工协议

![image-20211222142806858](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222142806858.png)

![image-20211222142816613](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222142816613.png)



### 无措信道上的停等式协议

![image-20211222142849660](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222142849660.png)

![image-20211222142927580](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222142927580.png)

![](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222142907489.png)



### 有错信道上的单工停等协议

![image-20211222143001972](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222143001972.png)

![image-20211222143006763](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222143006763.png)

![image-20211222143011580](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222143011580.png)

![image-20211222143021444](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222143021444.png)





### 滑动窗口协议

**基本思想：**

• **窗口机制**

​	− 发送方和接收方都具有一定容量的缓冲区（即窗口），发送端在收到确认之前可以发送多个帧

• **问题**

​	− 发送端一次可以发送多少个帧? 

​	− 某个帧出错或丢失怎么处理？

**目的**

​	• 对可以连续发出的最多帧数（已发出但未确认的帧）作限制

 **序号使用** 

​	• 循环重复使用有限的帧序号 

 **流量控制**：接收窗口驱动发送窗口的转动

​	• 发送窗口：其大小记作WT，表示在收到对方确认的信息之前，可以连续发出的最多数据帧数

​	• 接收窗口：其大小记作WR ，为可以连续接收的最多数据帧数

 **累计确认**：不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认





#### 回退N协议

![image-20211222143312750](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222143312750.png)

![image-20211222143322100](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222143322100.png)



#### 选择重传协议

![image-20211222143344197](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222143344197.png)

![image-20211222143351180](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222143351180.png)



# 介质访问子层（MAC子层）

## 重点

掌握两种ALOHA协议的工作原理

掌握CSMA工作原理及核心所在 

掌握经典以太网的拓扑

掌握经典以太网的帧结构

 掌握交换式以太网的特征

 掌握数据链路层交换的原理 

 掌握MAC地址表的维护



## 信道分配问题

信号：信号的通道

点到点通道：信道直接相连的两个端点

多点访问信道：多用户共享一根信道



**常见局域网拓扑：**

总线型，星型，环形

共同点：共享一根信道（别称：广播信道、多路访问信道、随机访问信道）



## 多路访问协议

![image-20211222220944729](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222220944729.png)



### ALOHA协议：

#### 纯ALOHA协议：

**原理：**想发就发

**特点：**

·冲突：两个或以上的帧 

• 随时可能冲突 

• 冲突的帧完全破坏

• 破坏了的帧要重传



#### 分隙ALOHA工作:

![image-20211222221224920](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221224920.png)

### 载波侦听多路访问协议CSMA

特点：先听后发

改进了Aloha的侦听，发送策略

![image-20211222221354407](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221354407.png)

#### 非持续式CSMA:

![image-20211222221433599](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221433599.png)



#### CSMA/CD(1-持续)

![image-20211222221508921](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221508921.png)

![image-20211222221530831](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221530831.png)

![image-20211222221536472](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221536472.png)



#### p-持续式CSMA

![image-20211222221558689](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221558689.png)



#### 比较

![image-20211222221614949](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221614949.png)

### 位图协议

![image-20211222221706000](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221706000.png)

### 令牌传递

![image-20211222221720135](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221720135.png)



### 二进制倒计数协议

![image-20211222221745928](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221745928.png)

### 自适应数搜索协议

![image-20211222221804089](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221804089.png)



## 以太网

### 经典以太网

![image-20211222221907352](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221907352.png)

![image-20211222221916327](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221916327.png)

![image-20211222221926144](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221926144.png)

![image-20211222221933040](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221933040.png)

### 交换式以太网

![image-20211222221953288](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222221953288.png)

### 快速以太网

![image-20211222222017128](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222222017128.png)

### 千兆以太网

![image-20211222222029352](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222222029352.png)

### 万兆以太网

![image-20211222222047673](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222222047673.png)

## 数据链路层交换

### 数据链路层交换原理

Ø 物理层设备扩充网络

​	• 扩大了冲突域，性能降低，安全隐患

Ø 数据链路层设备扩充网络

​	• 网桥或交换机 

​	• 分隔了冲突域

理想的网桥是透明的。 

​	• 即插即用，无需任何配置

​	• 网络中的站点无需感知网桥的存在与否



MAC地址表的构建-逆向学习源地址（老化时间默认300s）

MAC地址表的构建 

• 增加表项：帧的源地址对应的项不在表中

• 删除表项：老化时间到期 

• 更新表项：帧的源地址在表中，更新时间戳



**网桥对入境帧的处理：**

转发，泛洪，过滤



泛洪：

一个网段的数据被发送到无关网段 存在安全隐患 浪费网络资源

两种目的地址的帧，需要泛洪： 

• 广播帧：目的地址为FF-FF-FF-FF-FF-FF的数据帧 

• 未知单播帧：目的地址不在MAC地址转发表中的单播数据帧



### 小结

 

**逆向学习** 

根据帧的源地址在MAC地址表查找匹配表项， 

ü如果没有，则增加一个新表项（源地址、入境端口、帧到达时间），

ü如果有，则更新原表项的帧到达时间，重置老化时间。 



• 对入境帧的转发过程（三选一），查帧的目的地址是否在MAC地址表中

ü如果有，且入境端口≠出境端口，则从对应的出境端口转发帧； 

ü如果有，且入境端口=出境端口，则丢弃帧（!"#$）； 

ü如果没有，则向除入境端口以外的其它所有端口泛洪帧



# 网络层

## 重点

\1. 学习网络层服务：无连接和面向连接服务，数据包和虚电路网络

\2. 学习Internet网络层协议：IPv4/IPv6, ICMP, DHCP, NAT, ARP

\3. 掌握链路状态、距离矢量等路由算法，了解层次路由结构

\4. 掌握Internet路由协议：OSPF、RIP、BGP 

\5. 了解路由器工作原理：控制层和数据层，报文转发机制，交换结构



## 网络层服务

![image-20211222223234621](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222223234621.png)

### 网络层服务的实现

网络层实现端系统间多跳传输可达

网络层功能存在每台主机和路由器中 

• 发送端：将传输层数据单元封装在数据包中 

• 接收端：解析接收的数据包中，取出传输层数据单元，交付给传输层

• 路由器：检查数据包首部，转发数据包



### 网络层关键功能：

Ø 路由（控制面）

• 选择数据包从源端到目的端的路径 

• 核心：路由算法与协议

Ø 转发（数据面）

• 将数据包从路由器的输入接口传送到正 确的输出接口



### 无连接服务实现

Ø无连接服务：如寄信 

• 不需要提前建立连接 

Ø数据包服务

• 网络层向上只提供简单灵活无连接的、尽最大努力交付的数据包服务

• 发送分组时不需要先建立连接，每个分组独立发送

• 数据包独立转发，相同源-目的的数据包可能经过不同的路径

• 网络层不提供服务质量的承诺

Ø尽力而为交付 

• 传输网络不提供端到端的可靠传输服务：丢包、乱序、错误

• 优点：网络的造价大大降低，运行方式灵活，能够适应多种应用

（H1 发送给 H2 的分组可能沿着不同路径传送

在数据包分片的情况下，尽量还是沿相同路径）



## 网络协议

\1. IPv4协议

\2. IP地址

\3. ARP

\4. NAT 

\5. DHCP

\6. Internet控制报文协议



### ipv4协议：

IPv4协议，网际协议版本4，一种无连接的协议，是互联网的核心，也是使 

用最广泛的网际协议版本，其后继版本为IPv6 

Internet协议执行两个基本功能

• 寻址(addressing) 

• 分片(fragmentation)



#### ipv4数据包格式

![image-20211222224608175](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222224608175.png)

![image-20211222224615400](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222224615400.png)



#### 数据包分片：

```
Ø MTU（Maximum Transmission Unit） 最大传输单元
• 链路MTU
• 路径MTU (Path MTU)

Ø 分片策略
• 允许途中分片：根据下一跳链路的MTU实施分片
• 不允许途中分片：发出的数据包长度小于路径MTU（路径MTU发现机制）

Ø 重组策略
• 途中重组，实施难度太大
• 目的端重组（互联网采用的策略） 
• 重组所需信息：原始数据包编号、分片偏移量、是否收集所有分片

 IPv4分组在传输途中可以多次分片 
 	• 源端系统，中间路由器（可通过标志位设定是否允许路由器分片） 
 Ø IPv4分片只在目的IP对应的目的端系统进行重组 
 Ø IPv4分片、重组字段在基本IP头部
 	• 标识、标志、片偏移
```

![image-20211222224744642](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222224744642.png)



#### IP协**网络层基本功能**

Ø 支持多跳寻路将IP数据包送达目的端：*目的IP地址* 

Ø 表明发送端身份：*源IP地址* 

Ø 根据IP头部协议类型，提交给不同上层协议处理：*协议*

**其它相关问题**

Ø 数据包长度大于传输链路的MTU的问题，通过分片机制解决：*标识、标志、片偏移*

Ø 防止循环转发浪费网络资源（路由错误、设备故障…），通过跳数 限制解决：*生存时间TTL*

Ø IP报头错误导致无效传输，通过头部机校验解决：*首部校验和*议功能及报头字段总结



#### ip地址

Ø IP地址，网络上的每一台主机（或路由器）的每一个接口都会分配一个全球唯一的32位的标识符 

Ø 将IP地址划分为固定的类，每一类都由两个字段组成

Ø 网络号相同的这块连续IP地址空间称为地址的前缀，或网络前缀



分类ip**地址**

![image-20211222224952181](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222224952181.png)

![image-20211222224958129](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222224958129.png)



#### 子网划分

![image-20211222225038345](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222225038345.png)

![image-20211222225149898](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222225149898.png)

#### 无类域间路由

![image-20211222225251129](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222225251129.png)

![image-20211222225259458](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222225259458.png)



#### ip包转发

![image-20211222230113630](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230113630.png)

![image-20211222230120192](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230120192.png)



### ARP地址解析协议：

![image-20211222230237433](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230237433.png)

![image-20211222230257344](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230257344.png)

![image-20211222230333217](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230333217.png)

![image-20211222230338656](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230338656.png)



### 网络地址转换

![image-20211222230442280](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230442280.png)

![image-20211222230447961](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230447961.png)

![image-20211222230453760](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230453760.png)

```
• 出数据包：外出数据包用 NAT IP地址(全局), 新port # 替代 源IP地 址(私有), port # 

• NAT转换表：每个 (源IP地址, port #)到(NAT IP地址, 新port #) 映 射项 

• 入数据包：对每个入数据包的地址字段用存储在NAT表中的(源IP
地址, port #)替代对应的 (NAT IP地址, 新port #)
```

![image-20211222230528289](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230528289.png)



### ipv4地址获取

```
Ø 公有IP地址要求全球唯一 • ICANN（Internet Corporation for Assigned Names and Numbers）即互联网名字与编号分配机构向ISP分配，ISP再向所属机构或组织逐级分配

Ø 静态设定
• 申请固定IP地址，手工设定，如路由器、服务器 

Ø 动态获取
• 使用DHCP协议或其他动态配置协议
• 当主机加入IP网络，允许主机从DHCP服务器动态获取IP地址
• 可以有效利用IP地址，方便移动主机的地址获取
```



### DHCP动态主机配置协议

![image-20211222230623423](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230623423.png)

![image-20211222230629434](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230629434.png)

Ø DHCP 客户从UDP端口68以广播形式向服务器发送发现报文（ DHCPDISCOVER） 

Ø DHCP 服务器以广播形式发出提供报文（DHCPOFFER） 

Ø DHCP 客户从多个DHCP服务器中选择一个，并向其以广播形式发送

DHCP请求报文（DHCPREQUEST） 

Ø 被选择的DHCP服务器以广播形式发送确认报文（DHCPACK）



### ICMP协议

ØICMP: 互联网控制报文协议

​	• ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告

​	• 由主机和路由器用于网络层信息的通信

​	• ICMP 报文携带在IP 数据包中： IP上层协议号为1 

ØICMP报文类型 

​	• ICMP 差错报告报文 

​		• 终点不可达：不可达主机、不可达网络，无效端口、协议

​	• ICMP 询问报文 

​		• 回送请求/回答 (ping使用)



 

PING 用来测试两个主机之间的连通性

• PING 使用了 ICMP 回送请求与回送回答报文



**Traceroute和ICMP**

Ø源向目的地发送一系列UDP段(不可能的端口号) 

• 第一个 TTL =1 

• 第二个 TTL=2, 等 



Ø当第n个数据包到达第n和路由器: 

• 路由器丢弃数据包 

• 并向源发送一个ICMP报文 (类型 11, 编码0)

• 报文的源IP地址就是该路由器的IP地址

![image-20211222230850326](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211222230850326.png)



## 路由算法

```
1. 优化原则
2. 最短路径算法
3. 距离向量路由
4. 链路状态路由
5. 层次路由
```

### 路由算法的特性：

正确性，简单行，鲁棒性，稳定性，公平性



根据路由算法是否随网络的通信量或拓扑自适应划分 

• 静态路由选择策略（非自适应路由选择）

• 动态路由选择策略（自适应路由选择）



### 优化原则

![image-20211223134523647](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223134523647.png)



### 最短路径算法

Ø 定义

• 用于计算一个节点到其他所有节点的最短路径，主要特点是以起始点为

中心向外逐层扩展，直到扩展到终点为止

 

Dijkstra算法思想

• 建立网络图

​	• 节点表示路由器

•	 边表示通信线路/链路

•	 链路代价表示链路上的距离、信道宽度或通信开销等参数

• 根据算法在网络图上为某一对路由器找到最短路径

![image-20211223134615799](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223134615799.png)



### 距离向量路由

![image-20211223134640163](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223134640163.png)

![image-20211223134655150](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223134655150.png)

```
Ø 路由器启动时初始化自己的路由表 
	• 初始路由表包含所有直接相连的网络路径，距离均为0
路由器周期性地向其相邻路由器广播自己知道的路由信息 
Ø 相邻路由器可以根据收到的路由信息修改和刷新自己的路由表
Ø 路由器经过若干次更新后，最终都会知道到达所有网络的最短距离
Ø 所有的路由器都得到正确的路由选择信息时网络进入“收敛” （convergence）状态

```

**缺点**

Ø好消息传播快，坏消息传播慢，是距离向量路由的一个主要缺点

![image-20211223134917853](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223134917853.png)



### 链路状态路由

```
链路状态（Link State）路由可分为五个部分：
• 1. 发现邻居，了解他们的网络地址；
• 2. 设置到每个邻居的成本度量；
• 3. 构造一个分组，分组中包含刚收到的所有信息；
• 4. 将此分组发送给其他的路由器；
• 5. 计算到其他路由器的最短路径。
```

![image-20211223135102124](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223135102124.png)

![image-20211223135107438](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223135107438.png)

![image-20211223135114143](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223135114143.png)

![image-20211223135121076](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223135121076.png)

![image-20211223135128146](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223135128146.png)



### 算法比较

![image-20211223135216831](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223135216831.png)



## 路由协议

```
1. OPSF-内部网关路由协议
2. RIP-内部网关路由协议
3. BGP-外部网关路由协议
4. 标签交换和MPLS
```



### OSPF

#### 链路状态

```
Ø “链路状态”就是说明本路由器都和哪些路由器相邻，以及该链
路的“度量”(metric)
	• OSPF度量值一般包括费用、距离、时延、带宽等

Ø 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器
最终都能建立一个链路状态数据库LSDB 

Ø 这个数据库实际上就是区域内的拓扑结构图，它在区域内是一致 的（这称为链路状态数据库的同步）
```



#### 区域

```
Ø OSPF支持将一组网段组合在一起，称为一个区域

Ø 详细描述拓扑结构的链路状态信息仅在区域内传递，区域间传递的是抽象的路由信息 

Ø 使 用 层 次 结构的区 域 划 分 ， 上层的区 域 叫 做 主 干 区 域 (backbone area)，其他区域都必须与主干区域相连

Ø 非主干区域之间不允许直接发布区域间路由信息

Ø 区域也不能太大，在一个区域内的路由器最好不超过 200 个

Ø 划分区域可以缩小LSDB (link state database)规模，减少网络流
量
```

![image-20211223135752328](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223135752328.png)



### RIP

#### 概述

Ø 路由选择协议RIP（ Routing Information Protocol）是基于距离矢量

算法的协议

Ø 使用跳数衡量到达目的网络的距离

​	• RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短” 

​	• RIP 允许一条路径最多只能包含 15 个路由器

Ø RIP协议的基本思想

​	• 仅和相邻路由器交换信息

​	• 路由器交换的内容是自己的路由表 

​	• 周期性更新：30s



#### 工作过程

![image-20211223140008864](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223140008864.png)

![image-20211223140013998](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223140013998.png)



#### 协议特点

Ø RIP协议的特点

​	• 算法简单，易于实现

​	• 收敛慢

​	• 需要交换的信息量较大 

Ø RIP协议的适用场合 

​	• 中小型网络



### BGP-外部网关路由协议

Ø 路由协议

​	• 内部网关协议 IGP： 有 RIP、OSPF、ISIS 等多种具体的协议

​	• 外部网关协议 EGP：目前使用的协议就是 BGP

Ø 边界网关协议BGP (Border Gateway Protocol) 

​	• 目前互联网中唯一实际运行的自治域间的路由协议

Ø BGP功能

​	• eBGP：从相邻的AS获得网络可达信息

​	• iBGP： 将网络可达信息传播给AS内的路由器

​	• 基于网络可达信息和策略决定到其他网络的“最优”路由

![image-20211223140158271](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223140158271.png)

![image-20211223140213688](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223140213688.png)

![image-20211223140221037](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223140221037.png)

![image-20211223140227818](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223140227818.png)



#### 协议特点

```
Ø BGP 协议交换路由信息的节点数量级是自治系统数的量级 
Ø 每一个自治系统边界路由器的数目是很少的
Ø 在 BGP 刚刚运行时，BGP 的邻站交换整个的 BGP 路由表；以后只需
	要在发生变化时更新有变化的部分
ØBGP为每个AS提供：
	• 从邻居AS获取网络可达信息 ( eBGP协议 )
    • 传播可达信息给所有的域内路由器 ( iBGP协议 )
    • 根据“可达信息”和“策略”决定路由
```



# 传输层

## 重点

Ø 掌握传输层服务原理

​	• 传输层复用和分用

​	• 可靠数据传输

​	• 流量控制

​	• 拥塞控制

Ø 掌握因特网传输层协议：

​	• UDP协议

​	• TCP协议



## 传输层基本服务

传输层基本服务：将主机间交付扩展到进程间交付，通过复用和分用实现



### 复用和分用

复用（**发送端**）：传输层从多个套接字收集数据，交给网络层发送

分用（**接收端**）：传输层从网络层接收到的数据，交给正确的套接字

![image-20211223140535477](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223140535477.png)





#### 套接字与端口号

![image-20211223140830165](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223140830165.png)

![image-20211223140843167](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223140843167.png)



#### UDP分用：

ØUDP套接字使用<IP地址, 端口号>二元组进行标识

Ø接收方传输层收到一个UDP报文段后：

​	• 检查报文段中的目的端口号，将UDP报文段交付到具有该端口号的 

套接字

​	• <目的IP地址，目的端口号> 相同的UDP报文段被交付给同一个套

接字，与 <源IP地址，源端口号> 无关 

​	• 报文段中的 <源IP地址，源端口号> 被接收进程用来发送响应报文



#### TCP

Ø 一个TCP服务器为了同时服务很多个客户，使用两种套接字 

Ø 监听套接字： 

​	• 服务器平时在监听套接字上等待客户的连接请求，该套接字具有众所周知的端口号

Ø 连接套接字： 

​	• 服务器在收到客户的连接请求后，创建一个连接套接字，使用临时分配的端口号

​	• 服务器同时创建一个新的进程，在该连接套接字上服务该客户

​	• **每个连接套接字只与一个客户通信**，即只接收具有以下四元组的报文段： 

​		• 源IP地址 = 客户IP地址，源端口号 = 客户套接字端口号

​		• 目的IP地址 = 服务器IP地址，目的端口号 = 服务器监听套接字的端口号

Ø 连接套接字需要使用<源IP地址，目的IP地址，源端口号，目的端口号>四元组进行标识，服务器使用该四元组将TCP报文段交付到正确的连接套接字 



#### 小结

ØUDP套接字

​	• 使用<IP地址，端口号>二元组标识UDP套接字 

​	• 服务器使用一个套接字服务所有客户

ØTCP套接字

​	• 使用<源IP地址，目的IP地址，源端口号，目的端口号> 四元组标识连接套接字 

​	• 服务器使用一个监听套接字和多个连接套接字服务多个客户， 每个连接套接字服务一个客户



## 无连接服务UDP

### UDP提供的服务

Ø 网络层提供的服务（best-effort service）：

​	• 尽最大努力将数据包交付到目的主机 

​	• 不保证投递的可靠性和顺序 

​	• 不保证带宽及延迟要求 

Ø UDP提供的服务： 

​	• 进程到进程之间的报文交付 

​	• 报文完整性检查（可选）：检测并丢弃出错的报文 

Ø UDP需要实现的功能： 

​	• 复用和分用 

​	• 报文检错



### 报文格式

![image-20211223141457564](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223141457564.png)

![image-20211223141509675](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223141509675.png)

![image-20211223141519713](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223141519713.png)

![image-20211223141528085](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223141528085.png)

### UDP小结

**为什么需要UDP？**

 应用可以尽可能快地发送报文：

​	• 无建立连接的延迟

​	• 不限制发送速率（不进行拥塞控制和流量控制）

Ø 报头开销小

Ø 协议处理简单



**UDP适合哪些应用**？

Ø容忍丢包但对延迟敏感的应用：

​	• 如流媒体 

Ø以单次请求/响应为主的应用：

​	• 如DNS

Ø若应用要求基于UDP进行可靠传输： 

​	• 由应用层实现可靠性



## 面向连接服务TCP

### TCP概述

![image-20211223141732129](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223141732129.png)



### 报文结构

![image-20211223141758535](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223141758535.png)

![image-20211223141837903](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223141837903.png)



### 发送序号和确认序号

**发送序号**：数据载荷中第一个字节在字节流中的序号

**确认序号：**期望接收的下一个字节的序号

初始序号的选取：每个TCP实体维护一个32位计数器，每4微妙加1，建立时从中读取计数器当前值



![image-20211223142153789](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223142153789.png)



### 可靠的数据传输

ØTCP 在不可靠的IP服务上建立可靠的数据传输

Ø基本机制

​	̵ 发送端：流水线式发送数据、等待确认、超时重传

​	̵ 接收端：进行差错检测，采用累积确认机制

Ø乱序段处理：协议没有明确规定

​	̵ 接收端不缓存：可以正常工作，处理简单，但效率低

​	̵ 接收端缓存：效率高，但处理复杂



### 高度简化的TCP协议

高度简化的TCP协议：仅考虑可靠传输机制，且数据仅在一个方向上传输

Ø 接收方： 

​	• 确认方式：采用累积确认，仅在正确、按序收到报文段后，更新确认序号；其余情况，重复前一次的确认序号（与回退N协议类似） 

​	• 失序报文段处理：缓存失序的报文段（与选择重传协议类似） 

Ø 发送方： 

​	• 发送策略：流水线式发送报文段 

​	• 定时器的使用：仅对最早未确认的报文段使用一个重传定时器（与回退N协议类似） 

​	• 重发策略：仅在超时后重发最早未确认的报文段（与选择重传协议类似，因为接收端缓存了失序的报文段） 



#### **发送方处理事件**

Ø 收到应用数据：

​	• 创建并发送TCP报文段

​	• 若当前没有定时器在运行（没有已发送、未确认的报文段），启动定时器 

Ø 超时: 

​	• 重传包含最小序号的、未确认的报文段

​	• 重启定时器 

Ø 收到ACK： 

​	• 如果确认序号大于基序号（已发送未确认的最小序号）：

​	• 推进发送窗口（更新基序号）

​	• 如果发送窗口中还有未确认的报文段，启动定时器，否则终止定时器

![image-20211223142449274](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223142449274.png)

#### TCP接收端

![image-20211223142530396](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223142530396.png)

![image-20211223142543696](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223142543696.png)

#### 快速重传

![image-20211223142620281](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223142620281.png)



#### 小结

![image-20211223142640159](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223142640159.png)



### 流量控制

![image-20211223142839542](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223142839542.png)

![image-20211223143223436](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223143223436.png)



#### TCP进行流量控制

![image-20211223143312047](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223143312047.png)

![image-20211223143318923](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223143318923.png)

![image-20211223143328151](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223143328151.png)

![image-20211223143335436](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223143335436.png)

**接收方启发式策略**

接收端避免糊涂窗口综合症的策略：

​	• 通告零窗口之后，仅当窗口大小显著增加之后才发送更新的窗口通告

​	• 什么是显著增加：窗口大小达到缓存空间的一半或者一个MSS，取两者 的较小值 

Ø TCP执行该策略的做法：

​	• 当窗口大小不满足以上策略时，推迟发送确认（但最多推迟500ms，且至少每隔一个报文段使用正常方式进行确认），寄希望于推迟间隔内有 更多数据被消费 

​	• 仅当窗口大小满足以上策略时，才通告新的窗口大小



**发送方启发式策略**

![image-20211223143426034](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223143426034.png)

#### 小结

Ø TCP接收端

​	• 使用显式的窗口通告，告知发送方可用的缓存空间大小 

​	• 在接收窗口较小时，推迟发送确认 

​	• 仅当接收窗口显著增加时，通告新的窗口大小 

Ø TCP发送端

​	• 使用Nagle算法确定发送时机 

​	• 使用接收窗口限制发送的数据量，已发送未确认的字节数不超过接收窗 口的大小



### TCP连接

 建立一条TCP连接需要确定两件事： 

• 双方都同意建立连接（知晓另一方想建立连接） 

• 初始化连接参数（序号，MSS等）



**两次握手不可行**

 在一个不可靠的网络中，总会有一些意外发生：

• 报文传输延迟变化很大 

• 存在重传的报文段 

• 存在报文重排序



#### 三次握手

![image-20211223143631378](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223143631378.png)

\1. 客户TCP发送SYN 报文段（SYN=1, ACK=0） 

​	• 给出客户选择的起始序号

​	• 不包含数据

\2. 服务器TCP发送SYNACK报文段（SYN=ACK=1）（服务器端分配缓存和变量） 

​	• 给出服务器选择的起始序号

​	• 确认客户的起始序号

​	• 不包含数据

\3. 客户发送ACK报文段（SYN=0，ACK=1）（客户端分配缓存和变量）

​	• 确认服务器的起始序号

​	• 可能包含数据



#### 如何选择起始序号

Ø 为什么起始序号不从0开始？ 

​	• 若在不同的时间、在同一对套接字之间建立了连接，则新、旧连接上的序号有重叠，旧连接上重传的报文段会被误以为是新连接上的报文段 

Ø 可以随机选取起始序号吗？

​	• 若在不同的时间、在同一对套接字之间建立了连接，且新、旧连接上选择的起始序号x和y相差不大，那么新、旧连接上传输的序号仍然可能重叠 

Ø 结论：必须避免新、旧连接上的序号产生重叠

![image-20211223143732371](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223143732371.png)



#### 四次挥手

#### ![image-20211223143754802](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223143754802.png)

![image-20211223143802185](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223143802185.png)



### 网络拥塞

![image-20211223143842292](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223143842292.png)

#### 控制方法

端到端拥塞控制

​	• 网络层不向端系统提供反馈 

​	• 端系统通过观察丢包和延迟，自行推断拥塞的发生 

​	• TCP采用此类方法



### TCP拥塞控制

Ø TCP使用端到端拥塞控制机制：

​	• 发送方根据自己感知的网络拥塞程度，限制其发送速率

Ø 需要回答三个问题：

​	• 发送方如何感知网络拥塞？

​	• 发送方采用什么机制来限制发送速率？

​	• 发送方感知到网络拥塞后，采取什么策略调节发送速率？

![image-20211223143948277](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223143948277.png)

![image-20211223144022597](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223144022597.png)

![image-20211223144028430](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223144028430.png)

![image-20211223144033703](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223144033703.png)

![image-20211223144052370](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223144052370.png)

![image-20211223144101420](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223144101420.png)

![image-20211223144108591](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223144108591.png)



# 应用层

## 重点

\1. 掌握应用进程通信方式以及服务进程工作模式

\2. 掌握域名系统基本原理和工作机制

\3. 掌握电子邮件系统体系结构及基本工作原理

\7. 掌握Telnet、FTP、SNMP等应用层协议的工作原理



## 进程通信方式

Ø 每个应用层协议都是为了解决某一应用问题，通过位于不同主机中的多个应用进程之间的通信和协同工作来完成 

​	• 两台主机通信实际是其上对应的两个应用进程(process)在通信 

​	• 应用进程: 为解决具体应用问题而彼此通信的进程 

Ø 应用层的具体内容就是规定应用进程在通信时所遵循的协议

```
客户/服务器（C/S, Client/Server）方式
浏览器/服务器（B/S，Browser/Server） 方式
对等（P2P，Peer to Peer）方式
```



### C/S方式

Ø 应用层的许多协议是基于C/S方式，例如，在移动互联网环境下，每个应用APP都是一个客户端 

​	• 客户(client)和服务器(server)是指通信中所涉及的2个应用进程 

​	• 客户/服务器方式描述的是应用进程之间服务和被服务的关系

​	• 客户是服务请求方（主动请求服务，被服务） 

​	• 服务器是服务提供方（被动接受服务请求，提供服务） 

Ø C/S方式可以是面向连接的，也可以是无连接的

Ø 面向连接时，C/S通信关系一旦建立，通信就是双向的，双方地 位平等，都可发送和接收数据



**客户进程**

• 在进行通信时临时成为客户，它也可在本地进行其它的计算

• 用户计算机上运行，在打算通信时主动向远地服务器发起通信 

• 客户方必须知道服务器进程所在主机的IP地址才能发出服务请求

• 需要时可以与多个服务器进行通信



**服务进程**

• 专门用来提供某种服务的程序，可“同时”处理多个远地或本地客户的请求

• 必须始终处于运行状态才有可能提供服务

• 通信开始之前服务器进程不需要知道客户进程所在主机的IP地址，无论客户请求来自哪里，服务器进程被动等待服务请求的到来即可 

• 通常是当系统启动时即自动调用并一直运行着。某些服务器程序也可以由用户或其它进程在通信前启动 

• 被动等待并接受来自多个客户的通信请求



### B/S方式

Ø B/S方式可以看做C/S方式的特例，即客户软件改为浏览器了

Ø B/S方式采取浏览器请求、服务器响应的工作模式 

Ø 在B/S方式下，用户界面完全通过Web浏览器实现，一部分事务逻辑在前端实现，但主要的事务逻辑在服务器端实现

![image-20211223144638637](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223144638637.png)

![image-20211223144526864](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223144526864.png)



**特点**

• 界面统一，使用简单。客户端只需要安装浏览器软件 

• 易于维护。对应用系统升级时，只需更新服务器端的软件，减轻了系通维护和升级的成本

• 可扩展性好。采用标准的TCP/IP和HTTP协议，具有良好的扩展性

• 信息共享度高。HTML是数据格式的一个开放标准，目前大多数流行的软件 均支持HTML 

• 需要注意的是，在一种浏览器环境下开发的界面在另一种浏览器环境下可能有不完全适配的情况，这时需要安装对应的浏览器



### 对等方式

Ø 对等方式是指两个进程在通信时并不区分服务的请求方和服务的提供方 

​	• 只要两个主机都运行P2P软件，它们就可以进行平等、对等的通信 

​	• 双方都可以下载对方存储在硬盘中的共享文档 

Ø 音频/视频应用推动了P2P对等通信方式的发展 

Ø 音频/视频流量已占主要比例

Ø P2P方式从本质上看仍然是使用了C/S方式，但强调的是通信过 程中的对等，这时每一个P2P进程既是客户同时也是服务器



### 服务器进程工作方式

Ø 循环方式(iterative mode)

​	• 一次只运行一个服务进程 

​	• 当有多个客户进程请求服务时，服务进程就按请求的先后顺序依次做出 响应 (阻塞方式) 

Ø 并发方式(concurrent mode) 

​	• 可以同时运行多个服务进程 

​	• 每一个服务进程都对某个特定的客户进程做出响应 (非阻塞方式)



Ø 无连接循环方式服务

• 使用无连接的UDP服务进程通常都工作在循环方式，即一个服务进程在同一时间只能向一个客户进程提供服务。(顺序服务) 

• 服务进程收到客户进程的请求后，就发送UDP用户数据报响应该客户

• 对其他客户进程发来的请求则暂时不予理睬，这些请求都在服务端的队列中排队等 候服务进程的处理 

• 当服务进程处理完毕一个请求时，就从队列中读取来自下一个客户进程的请求，然 后继续处理

![image-20211223144908799](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223144908799.png)



Ø 面向连接的并发方式服务

• 面向连接的TCP服务进程通常都工作在并发服务方式，服务进程在同一时间可同时向多个客户进程提供服务。(并发服务) 

• 在TCP服务进程与多个客户进程之间必须建立多条TCP连接，每条TCP连接在其数据传送完毕后释放 

• 一个TCP连接对应一个（熟知）服务端口 

• 主服务进程在熟知端口等待客户进程发出的请求。一旦收到客户的请求，就创建一个从属服务进程，并指明从属服务进程使用临时套接字与该客户建立TCP连接，然后主服务进程继续在原来的熟知端口等待向其他客户提供服务 

![image-20211223144955850](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223144955850.png)

![image-20211223145006418](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223145006418.png)



## 域名系统

**Ø 域名系统概述**

```
• 域名系统（DNS，Domain Name System）是互联网重要的基础设施之一，向所有需要域名解析的应用提供服务，主要负责将可读性好的域名映射成IP地址
• Internet采用层次结构的命名树作为主机的名字，并使用分布式的域名系 统 DNS。Internet的DNS是一个联机分布式数据库系统
• 名字到域名的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的节点上运行，相应的节点也称为名字服务器(Name Server)或域 名服务器(Domain Name Server)
```



**域名结构**

```
 Internet的域名结构采用了层次树状结构的命名方法
Ø 域名的结构由若干个分量组成，各分量之间用小数点(.)隔开，总长不超过255个字符
Ø 各分量分别代表不同级别的域名。(≤63字符)
Ø 合法域名中，点“.”的个数至少为一个
Ø 通常，点“.”对应的英文单词为dot，也可以读为point

```

![image-20211223145232771](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223145232771.png)

**域名服务器**

![image-20211223145251891](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223145251891.png)

![image-20211223145306000](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223145306000.png)

![image-20211223145337717](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223145337717.png)

```
Ø 根据对应域的层次，权威域名服务器又进一步分为以下类别
• 根域名服务器(root name server) /根服务器(root server)
• 顶级域域名服务器(TLD name server)
• 二级域域名服务器(second level domain name server)
• 三级域域名服务器(third level domain name server)
• ......
Ø 三级域及以下的域名服务器(例如nankai.edu.cn)通常在用户本地区
域，因此三级域及以下的域名服务器也统称为本地域名服务器
```



### 域名解析

Ø 当某一应用进程需要进行域名解析时，该应用进程将域名放在DNS请求报文（UDP数据报, 端口号为53）发给递归服务器（使用UDP是为了减少开销）。递归服务器得到查询结果后, 将对应IP地址放在应答报文中返回给应用进程

Ø 域名查询有递归查询(recursive query)和迭代查询(或循环查询iterative query)两种方式

• 主机向递归解析器/本地域域名服务器的查询一般采用递归查询

• 递归解析器/本地域域名服务器向根服务器可以采用递归查询，但一般优先采用迭代查询

![image-20211223145514040](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223145514040.png)

![image-20211223145519766](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223145519766.png)



## 电子邮件

### 体系结构

![image-20211223145600122](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223145600122.png)

![image-20211223145617226](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223145617226.png)

```
Ø 邮件传输代理将邮件从发件人中继给收件人 
Ø 邮件传输采用的协议是SMTP
	• SMTP利用TCP可靠地从客户向服务器传递邮件，使用端口25
	• 直接投递: 发送端直接到接收端 
	• SMTP的3个阶段：连接建立、邮件传送、连接关闭
	• 命令/响应（以HTTP为例） 
		• 命令: ASCII字符串
		• 响应: 状态码+短语
```



​	POP3协议：

![image-20211223145742582](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223145742582.png)

![image-20211223145747958](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223145747958.png)



IMAP

```
Ø IMAP—Internet邮件访问协议[RFC 2060] 
• 用于最终交付的主要协议
• IMAP是POP3的改进版 
• 邮件服务器运行侦听端口为143的IMAP服务
• 用户代理运行一个IMAP客户端
• 客户端连接到服务器并开始发出命令
```

**特性**

```
Ø IMAP允许用户在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件
Ø IMAP服务器把每个邮件与一个文件夹联系起来
	• 当邮件第一次到达服务器时，它与收件人的INBOX文件夹相关联
	• 收件人能够把邮件移到一个新的文件夹中，阅读邮件，删除邮件等
Ø IMAP还为用户提供了在远程文件夹中查询邮件的命令，按指定条件去查询匹配的邮件
Ø 与POP3不同，IMAP服务器维护了IMAP会话的用户状态信息 
	• 例如，文件夹的名字、哪些邮件与哪些文件夹相关联
Ø IMAP具有允许用户代理获取邮件某些部分的命令
	• 例如，一个用户代理可以只读取一个邮件的首部
Ø 用户代理和其邮件服务器之间使用低带宽连接时
	• 用户可能并不想取回邮箱中的所有邮件
	• 避免可能包含如音频或视频片断的大邮件
```



### Telnet:

Ø 远程登录是网络最早提供的基本服务之一

​	• 通过终端仿真协议实现对远程计算机系统的访问，就像访问本地资源一样 

​	• 这个过程对用户是透明的 

Ø 远程登录需要解决异构计算机系统的差异性问题

​	• 主要体现在对终端键盘输入命令的解释上 

Ø Telnet协议最早出现在20世纪60年代后期

Ø 1983年由RFC 854确定为Internet标准 

Ø Telnet协议使用C/S方式实现 

​	• 在本地系统运行Telnet客户进程，在远程主机运行Telnet服务器进程

Ø Telnet协议使用TCP连接通信 

​	• 服务器进程默认监听TCP 23端口，使用主进程等待新的请求，并产生从属进程来处理每一个连接

Ø Telnet协议引入网络虚拟终端NVT（Network Virtual Terminal） 

​	• 使用一种专门的键盘定义来屏蔽不同计算机系统对键盘输入的差异性

​	• 定义客户进程与远程服务器进程之间的交互过程

Ø NVT是Telnet协议定义的一组通用字符集

​	• 统一的数据表示方式来保证不同硬件、软件与数据格式的终端与主机之间通信的兼容性

Ø Telnet交互过程及特点

​	• 本地终端输入的字符首先由本地Telnet客户进程转换为NVT格式

​	• 通过网络将NVT格式的字符传输到远程主机

​	• 远程Telnet服务器进程将NVT格式的字符转换为远程主机能够识别和处理的字符格式

​	• 特点：使用Telnet协议在网络中传输的数据都是NVT格式，不同的用户终端与服务器进程均与本地终端格式无关 

![image-20211223150007591](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223150007591.png)



### FTP

 

网络环境下复制文件的复杂性 

​	• 计算机存储数据的格式不同

​	• 文件目录结构和文件命名规则不同

​	• 对于相同的文件存取功能，操作系统使用的命令不同

​	• 访问控制方法不同

Ø 文件传输协议FTP(File Transfer Protocol)是Internet上使用最广泛的应用层协议之一

​	• FTP提供交互式的访问，允许用户指明文件的类型与格式，并允许文件具有存取权限

​	• FTP屏蔽了各计算机系统的细节，适用于在异构网络中任意计算机之间传送文件

​	• RFC 959早在1985年就已经成为Internet的正式标准

Ø FTP使用C/S方式实现

Ø FTP工作过程

​	• 服务器主进程打开TCP 21端口，等待客户进程发出的连接请求

​	• 客户可以用分配的任意一个本地端口号与服务器进程的TCP 21端口进行连接

​	• 客户请求到来时，服务器主进程启动从属进程来处理客户进程发来的请求

​	• 服务器从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他子进程 

​	• 服务器主进程返回，继续等待接收其他客户进程发来的连接请求，服务器主进程与从属进程并行工作

简单文件传输协议 TFTP 

​	• TFTP(Trivial File Transfer Protocol) 是一个很小且易于实现的文件传输协议

​	• 使用C/S方式和UDP协议实现 

​	• 只支持文件传输而不支持交互 

​	• 没有庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别 

​	• 支持ASCII 码或二进制传送

​	• 支持对文件进行读或写 

​	• 使用很简单的首部



### SNMP

![image-20211223150122753](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223150122753.png)

![image-20211223150127374](C:\Users\11346\AppData\Roaming\Typora\typora-user-images\image-20211223150127374.png)

# stock编程

## 实验一

```python
import random
from socket import *

serverSocket = socket(AF_INET, SOCK_DGRAM)
serverSocket.bind(('', 12000))

while True:
    rand = random.randint(0, 10)
    message, address = serverSocket.recvfrom(1024)

    message = message.upper()
    print(message)
    print(address)

    if rand < 3:
        continue
    serverSocket.sendto(message, address)

```

```
import random
from socket import *
import time

tcpSocket = socket(AF_INET, SOCK_DGRAM)
tcpSocket.settimeout(1)
data = 'hello world'
i = 0
count = 0
maxtime = 0
mintime = 1
sum = 0
while True:
    i = i + 1

    start = time.time()

    try:
        tcpSocket.sendto(data.encode('gbk'), ('127.0.0.1', 12000))
        message, address = tcpSocket.recvfrom(1024)
        after = time.time()

        run_time = (after - start)

        sum = sum + run_time
        maxtime = max(maxtime, run_time)
        mintime = min(mintime, run_time)
        count = count + 1
        print(message, 'RTT：', run_time, "s")
    except timeout:
        print('请求失败')

    if i == 10:
        break

loss = (10 - count) * 10
print('已发送：10', '已接收：', count, '丢包率：', loss, '%')
print('最大用时：', maxtime, 's,最小用时：', mintime, 's,平均用时', sum / count, 's')

```



实验二

```
import os
from socket import *

serverSocket = socket(AF_INET, SOCK_STREAM)
serverSocket.bind(('', 7788))
serverSocket.listen(128)

"""
处理请求内容
文件不存在时网页显示文件不存在
文件存在时显示文件内容
"""""


def request_handler(message):
    if not os.path.exists(message):
        body = '该文件不存在'
    else:
        f = open(message, 'r', encoding='gbk')
        body = f.read()
        f.close()

    response_line = "HTTP/1.1 200 OK\r\n"  # 响应行
    response_header = "Server:python2020\r\n"  # 响应头
    response_blank = '\r\n'  # 空行
    response_data = (response_line + response_header + response_blank + body).encode('GBK')
    return response_data


while True:
    print('Ready to serve...')
    connectionSocket, addr = serverSocket.accept()
    try:

        # 打印连接的对象
        print('连接的对象是:%s,ip:%s,port:%s' % (connectionSocket, addr[0], addr[1]))
        recv_data = connectionSocket.recv(1024)

        # 获得请求内容
        message = recv_data[5:15]

        print(message)
        #获取返回数据
        req = request_handler(message)

        connectionSocket.send(req)
        connectionSocket.close()
    except IOError:
        print('error')

serverSocket.close()

```



实验三

```
# SMTPClient.py
import base64
from socket import *

#发送的邮件信息
msg = "\r\n I love computer networks!"
endMsg = "\r\n.\r\n"

# 选择一个邮件服务
mailServer = "smtp.qq.com"

# 发送方地址和接收方地址，from 和 to
fromAddress = "1134684784@qq.com"
toAddress = "3279457524@qq.com"
# 发送方，验证信息，由于邮箱输入信息会使用base64编码，因此需要进行编码
username =base64.b64encode('1134684784@qq.com'.encode()) .decode()  # 输入自己的用户名对应的编码
password = base64.encodebytes("qikmntgtmgqgbadh".encode() ) .decode()# 此处不是自己的密码，而是开启SMTP服务时对应的授权码

# 创建客户端套接字并建立连接
serverPort = 25  # SMTP使用25号端口
clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((mailServer, serverPort))
# 从客户套接字中接收信息
recv = clientSocket.recv(1024).decode()
print(recv)

if '220' != recv[:3]:
    print('220 reply not received from server.')

# 发送 HELO 命令并且打印服务端回复
# 开始与服务器的交互，服务器将返回状态码250,说明请求动作正确完成
heloCommand = 'HELO Alice\r\n'
clientSocket.send(heloCommand.encode())
recv1 = clientSocket.recv(1024).decode()
print(recv1)

if '250' != recv1[:3]:
    print('250 reply not received from server.')

# 发送"AUTH LOGIN"命令，验证身份.服务器将返回状态码334（服务器等待用户输入验证信息）
clientSocket.sendall('AUTH LOGIN\r\n'.encode())
recv2 = clientSocket.recv(1024).decode()
print(recv2)

if '334' != recv2[:3]:
    print('334 reply not received from server.')

# 发送验证信息
clientSocket.sendall((username + '\r\n').encode())
recvName = clientSocket.recv(1024).decode()
print(recvName)

if '334' != recvName[:3]:
    print('334 reply not received from server')

clientSocket.sendall((password + '\r\n').encode())
recvPass = clientSocket.recv(1024).decode()
print(recvPass)

# 如果用户验证成功，服务器将返回状态码235
if '235' != recvPass[:3]:
    print('235 reply not received from server')

# TCP连接建立好之后，通过用户验证就可以开始发送邮件。邮件的传送从MAIL命令开始，MAIL命令后面附上发件人的地址。
# 发送 MAIL FROM 命令，并包含发件人邮箱地址
clientSocket.sendall(('MAIL FROM: <' + fromAddress + '>\r\n').encode())
recvFrom = clientSocket.recv(1024).decode()
print(recvFrom)

if '250' != recvFrom[:3]:
    print('250 reply not received from server')

# 接着SMTP客户端发送一个或多个RCPT (收件人recipient的缩写)命令，格式为RCPT TO: <收件人地址>。
# 发送 RCPT TO 命令，并包含收件人邮箱地址，返回状态码 250
clientSocket.sendall(('RCPT TO: <' + toAddress + '>\r\n').encode())
recvTo = clientSocket.recv(1024).decode()
print(recvTo)

if '250' != recvTo[:3]:
    print('250 reply not received from server')

# 发送 DATA 命令，表示即将发送邮件内容。服务器将返回状态码354
clientSocket.send('DATA\r\n'.encode())
recvData = clientSocket.recv(1024).decode()
print(recvData)
if '354' != recvData[:3]:
    print('354 reply not received from server')

# 编辑邮件信息，发送数据
subject = "I love computer networks!"
contentType = "text/plain"

message = 'from:' + fromAddress + '\r\n'
message += 'to:' + toAddress + '\r\n'
message += 'subject:' + subject + '\r\n'
message += 'Content-Type:' + contentType + '\t\n'
message += '\r\n' + msg
clientSocket.sendall(message.encode())

# 以"."结束。请求成功返回 250
clientSocket.sendall(endMsg.encode())
recvEnd = clientSocket.recv(1024).decode()
print(recvEnd)
if '250' != recvEnd[:3]:
    print('250 reply not received from server')

# 发送"QUIT"命令，断开和邮件服务器的连接
clientSocket.sendall('QUIT\r\n'.encode())

clientSocket.close()


```

